3. Bootstrap hist√≥rico

Antes do WS, buscar 300‚Äì1000 candles via REST para preencher a deque de c√°lculo dos indicadores.

Depois, o WS passa a atualizar a √∫ltima barra (enquanto is_closed=False) e fechar a barra ao final.

4. Pipeline ass√≠ncrono

asyncio.Queue para mensagens do WS ‚Üí ‚Äúcoalescer‚Äù por 1s:

Dentro do tick de 1s, manter apenas o √∫ltimo close/√∫ltimo estado do candle corrente.

Processar micro-batch:

Atualizar janela de candles.

Rodar Classic + SMC.

Combinar em conflu√™ncia com hysteresis.

Se estado mudou ‚Üí enviar ‚Äúevento de mudan√ßa‚Äù para UI.

5. UI com rich.Live

Construir fun√ß√µes que retornem rich.Panel/Table a partir do estado atual.

No loop da UI, a cada 1s, reconstruir os pain√©is a partir do estado (n√£o imprimir!).

Destaques:

BUY: seta ‚Üë verde; SELL: seta ‚Üì vermelha; HOLD: ‚Ä¢ cinza.

Mostrar ‚Äúlat√™ncia‚Äù (agora ‚àí event_time), spread desde √∫ltima mudan√ßa, e top-3 raz√µes.

(esqueleto)

from rich.live import Live
from rich.table import Table
from rich.panel import Panel

def render_ui(state):
    hdr = Table.grid()
    hdr.add_row(f"[bold]Provider:[/bold] {state.provider}",
                f"[bold]Symbol:[/bold] {state.symbol}",
                f"[bold]TF:[/bold] {state.interval}",
                f"[bold]Latency:[/bold] {state.latency_ms} ms")

    price_panel = Panel.fit(f"üí∞ {state.price:,.2f}  Œî since state: {state.delta_since:.2f}",
                            title="Pre√ßo Atual", border_style="cyan")

    conf_table = Table(title="Conflu√™ncia (SMC + Cl√°ssicos)")
    conf_table.add_column("Estado")
    conf_table.add_column("Conf.")
    conf_table.add_column("Score")
    conf_table.add_column("Raz√µes")
    conf_table.add_row(state.label_emoji, f"{state.confidence:.2f}",
                       f"{state.score:.3f}", ", ".join(state.top_reasons))

    events = Table(title="√öltimas Mudan√ßas")
    events.add_column("Quando")
    events.add_column("A√ß√£o")
    events.add_column("Pre√ßo")
    for e in state.last_events:
        events.add_row(e.when, e.action, f"{e.price:,.2f}")

    layout = Panel.fit(
        Group(hdr, price_panel, conf_table, events),
        title="MARKET MANUS ‚Äî LIVE",
        border_style="magenta"
    )
    return layout

async def ui_loop(state):
    with Live(render_ui(state), refresh_per_second=4) as live:
        while True:
            await asyncio.sleep(1.0)
            live.update(render_ui(state))
6. Integra√ß√£o SMC + Classic (explicabilidade)

Em cada detector, retornar: signal ‚àà {BUY, SELL, HOLD}, score ‚àà [0,1], reasons: list[str], tags: set[str].

No agregador, manter:

ranking das raz√µes (por ganho de confian√ßa) ‚Üí top-k no painel.

tags agrupadas [SMC] e [CLASSIC] para r√≥tulos compactos.

7. Thresholds, Hysteresis e Cooldown

Thresholds configur√°veis em config/settings.json.

Hysteresis: enter_buy >= 0.60, exit_buy <= 0.45 (similar para SELL).

Cooldown: bloquear nova troca de r√≥tulo por N segundos ap√≥s mudan√ßa (evita ‚Äúchurn‚Äù).

8. Telemetria leve

Contar ticks processados, mensagens coalescidas, reconex√µes.

Exibir no header, √∫til para tuning de performance.

9. Teste local e Resili√™ncia

Simular perda de socket (fechar WS) e garantir reconex√£o com backoff+jitter.

Testar s√≠mbolos e timeframes diferentes; medir lat√™ncia exibida.

Se o provider for Bybit, plugar t√≥pico de kline.<interval>.<symbol> com a mesma interface.

AJUSTES ESPEC√çFICOS DE PERFORMANCE

refresh_per_second=4 na Live j√° √© fluido e n√£o ‚Äúspamma‚Äù.

Micro-batch = 1s: suficiente para 1m-klines; se usar trades/aggTrades, aumentar para 250‚Äì500ms.

Limitar hist√≥rico em mem√≥ria (ex.: deque de 2000 candles).

NumPy/Pandas vetorizado para indicadores; evitar recomputar s√©ries inteiras, atualizar incrementalmente.

ENTREGAS ESPERADAS (CHECKLIST)

 Novo m√≥dulo WS (BinanceUSWS e BybitWS) com reconex√£o + backoff+jitter.

 Bootstrap REST e fallback quando WS cair.

 Loop ass√≠ncrono com asyncio.Queue, debounce/coalescing de 1s.

 UI Rich com Live: 4 pain√©is (status, pre√ßo, conflu√™ncia, √∫ltimas mudan√ßas).

 Integra√ß√£o dos detectores SMC + Classic com explicabilidade (raz√µes + tags).

 Thresholds/hysteresis/cooldown configur√°veis.

 M√©tricas leves no header (lat√™ncia, msgs/s, reconex√µes).

 Testado em Binance.US e Bybit alternando via .env.

ARQUIVOS A EDITAR/CRIAR

market_manus/data_providers/market_data_ws.py (novos WS providers)

market_manus/engines/stream_runtime.py (pipeline asyncio + filas)

market_manus/cli/live_view.py (UI Rich Live)

Integrar no main.py um modo --live que inicia o stream runtime