"""
Strategy Lab Professional V6 - Vers√£o Completa com Todas as Estrat√©gias
Localiza√ß√£o: market_manus/strategy_lab/STRATEGY_LAB_PROFESSIONAL_V6.py
Data: 24/09/2025

FUNCIONALIDADES:
‚úÖ 8 Estrat√©gias completas: RSI, EMA, Bollinger, MACD, Stochastic, Williams %R, ADX, Fibonacci
‚úÖ Sele√ß√£o de per√≠odo temporal personalizado (data inicial e final)
‚úÖ Backtesting com dados reais da API Bybit
‚úÖ C√°lculos matem√°ticos precisos dos indicadores
‚úÖ Capital management integrado
‚úÖ Relat√≥rios detalhados com m√©tricas financeiras
‚úÖ Interface interativa completa
"""

import os
import sys
import json
import time
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from pathlib import Path

# Importar as novas estrat√©gias
sys.path.append(str(Path(__file__).parent.parent.parent))

class StrategyLabProfessionalV6:
    """Strategy Lab Professional V6 - Vers√£o completa com todas as estrat√©gias"""
    
    def __init__(self, data_provider=None, capital_manager=None):
        self.data_provider = data_provider
        self.capital_manager = capital_manager
        
        # Estrat√©gias dispon√≠veis (8 estrat√©gias completas)
        self.strategies = {
            "rsi_mean_reversion": {
                "name": "RSI Mean Reversion",
                "description": "Revers√£o √† m√©dia baseada no RSI",
                "emoji": "üìä",
                "type": "Oscillator",
                "params": {
                    "rsi_period": {"default": 14, "min": 7, "max": 30, "description": "Per√≠odo do RSI"},
                    "oversold": {"default": 30, "min": 20, "max": 35, "description": "N√≠vel de sobrevenda"},
                    "overbought": {"default": 70, "min": 65, "max": 80, "description": "N√≠vel de sobrecompra"}
                },
                "calculate": self._calculate_rsi_strategy
            },
            "ema_crossover": {
                "name": "EMA Crossover",
                "description": "Cruzamento de m√©dias m√≥veis exponenciais",
                "emoji": "üìà",
                "type": "Trend Following",
                "params": {
                    "fast_ema": {"default": 12, "min": 5, "max": 50, "description": "EMA r√°pida"},
                    "slow_ema": {"default": 26, "min": 20, "max": 200, "description": "EMA lenta"}
                },
                "calculate": self._calculate_ema_strategy
            },
            "bollinger_breakout": {
                "name": "Bollinger Bands Breakout",
                "description": "Rompimento das Bandas de Bollinger",
                "emoji": "üéØ",
                "type": "Volatility",
                "params": {
                    "period": {"default": 20, "min": 10, "max": 50, "description": "Per√≠odo das bandas"},
                    "std_dev": {"default": 2.0, "min": 1.5, "max": 3.0, "description": "Desvio padr√£o"}
                },
                "calculate": self._calculate_bollinger_strategy
            },
            "macd": {
                "name": "MACD",
                "description": "Moving Average Convergence Divergence",
                "emoji": "üìä",
                "type": "Momentum",
                "params": {
                    "fast_period": {"default": 12, "min": 5, "max": 20, "description": "Per√≠odo EMA r√°pida"},
                    "slow_period": {"default": 26, "min": 20, "max": 50, "description": "Per√≠odo EMA lenta"},
                    "signal_period": {"default": 9, "min": 5, "max": 15, "description": "Per√≠odo linha de sinal"}
                },
                "calculate": self._calculate_macd_strategy
            },
            "stochastic": {
                "name": "Stochastic Oscillator",
                "description": "Oscilador Estoc√°stico %K e %D",
                "emoji": "üìà",
                "type": "Oscillator",
                "params": {
                    "k_period": {"default": 14, "min": 5, "max": 25, "description": "Per√≠odo %K"},
                    "d_period": {"default": 3, "min": 3, "max": 10, "description": "Per√≠odo %D"},
                    "oversold": {"default": 20, "min": 10, "max": 30, "description": "N√≠vel oversold"},
                    "overbought": {"default": 80, "min": 70, "max": 90, "description": "N√≠vel overbought"}
                },
                "calculate": self._calculate_stochastic_strategy
            },
            "williams_r": {
                "name": "Williams %R",
                "description": "Williams Percent Range Oscillator",
                "emoji": "üìâ",
                "type": "Oscillator",
                "params": {
                    "period": {"default": 14, "min": 5, "max": 25, "description": "Per√≠odo de lookback"},
                    "oversold": {"default": -80, "min": -90, "max": -70, "description": "N√≠vel oversold"},
                    "overbought": {"default": -20, "min": -30, "max": -10, "description": "N√≠vel overbought"}
                },
                "calculate": self._calculate_williams_r_strategy
            },
            "adx": {
                "name": "ADX",
                "description": "Average Directional Index",
                "emoji": "üéØ",
                "type": "Trend Strength",
                "params": {
                    "period": {"default": 14, "min": 10, "max": 20, "description": "Per√≠odo ADX"},
                    "adx_threshold": {"default": 25, "min": 20, "max": 30, "description": "Threshold tend√™ncia forte"}
                },
                "calculate": self._calculate_adx_strategy
            },
            "fibonacci": {
                "name": "Fibonacci Retracement",
                "description": "N√≠veis de Retra√ß√£o de Fibonacci",
                "emoji": "üî¢",
                "type": "Support/Resistance",
                "params": {
                    "lookback_period": {"default": 50, "min": 20, "max": 100, "description": "Per√≠odo lookback"},
                    "tolerance_pct": {"default": 0.5, "min": 0.1, "max": 2.0, "description": "Toler√¢ncia (%)"}
                },
                "calculate": self._calculate_fibonacci_strategy
            }
        }
        
        # Timeframes dispon√≠veis
        self.timeframes = {
            "1": {"name": "1 minuto", "bybit_interval": "1", "description": "Scalping ultra-r√°pido"},
            "5": {"name": "5 minutos", "bybit_interval": "5", "description": "Scalping r√°pido"},
            "15": {"name": "15 minutos", "bybit_interval": "15", "description": "Swing trading curto"},
            "30": {"name": "30 minutos", "bybit_interval": "30", "description": "Swing trading m√©dio"},
            "60": {"name": "1 hora", "bybit_interval": "60", "description": "Swing trading longo"},
            "240": {"name": "4 horas", "bybit_interval": "240", "description": "Position trading"},
            "D": {"name": "1 dia", "bybit_interval": "D", "description": "Investimento longo prazo"}
        }
        
        # Assets dispon√≠veis
        self.available_assets = {
            "BTCUSDT": {"name": "Bitcoin", "emoji": "ü™ô", "min_volume": 1000000000},
            "ETHUSDT": {"name": "Ethereum", "emoji": "üíé", "min_volume": 500000000},
            "BNBUSDT": {"name": "Binance Coin", "emoji": "üü°", "min_volume": 100000000},
            "SOLUSDT": {"name": "Solana", "emoji": "‚ö°", "min_volume": 50000000},
            "XRPUSDT": {"name": "XRP", "emoji": "üíß", "min_volume": 100000000},
            "ADAUSDT": {"name": "Cardano", "emoji": "üîµ", "min_volume": 50000000},
            "DOGEUSDT": {"name": "Dogecoin", "emoji": "üêï", "min_volume": 50000000},
            "MATICUSDT": {"name": "Polygon", "emoji": "üü£", "min_volume": 30000000}
        }
        
        # Configura√ß√µes atuais
        self.selected_asset = None
        self.selected_timeframe = None
        self.selected_strategy = None
        self.strategy_params = {}
        self.custom_start_date = None
        self.custom_end_date = None
        
        # Hist√≥rico de testes
        self.test_history = []
    
    def run_interactive_mode(self):
        """Executa o modo interativo do Strategy Lab"""
        while True:
            self._show_main_menu()
            choice = input("\\nüî¢ Escolha uma op√ß√£o (0-8): ").strip()
            
            if choice == '0':
                print("\\nüëã Saindo do Strategy Lab Professional V6...")
                break
            elif choice == '1':
                self._asset_selection_menu()
            elif choice == '2':
                self._strategy_configuration_menu()
            elif choice == '3':
                self._timeframe_selection_menu()
            elif choice == '4':
                self._period_selection_menu()
            elif choice == '5':
                self._run_historical_backtest()
            elif choice == '6':
                self._run_realtime_test()
            elif choice == '7':
                self._view_test_results()
            elif choice == '8':
                self._export_results()
            else:
                print("‚ùå Op√ß√£o inv√°lida")
                input("\\nüìñ Pressione ENTER para continuar...")
    
    def _show_main_menu(self):
        """Mostra o menu principal do Strategy Lab"""
        print("\\n" + "="*80)
        print("üî¨ STRATEGY LAB PROFESSIONAL V6 - MENU PRINCIPAL")
        print("="*80)
        
        # Status atual
        asset_status = f"‚úÖ {self.selected_asset}" if self.selected_asset else "‚ùå N√£o selecionado"
        strategy_status = f"‚úÖ {self.strategies[self.selected_strategy]['name']}" if self.selected_strategy else "‚ùå N√£o selecionada"
        timeframe_status = f"‚úÖ {self.timeframes[self.selected_timeframe]['name']}" if self.selected_timeframe else "‚ùå N√£o selecionado"
        
        print(f"üìä CONFIGURA√á√ÉO ATUAL:")
        print(f"   ü™ô Ativo: {asset_status}")
        print(f"   üìà Estrat√©gia: {strategy_status}")
        print(f"   ‚è∞ Timeframe: {timeframe_status}")
        
        if self.custom_start_date and self.custom_end_date:
            print(f"   üìÖ Per√≠odo: {self.custom_start_date} at√© {self.custom_end_date}")
        else:
            print(f"   üìÖ Per√≠odo: Padr√£o (√∫ltimos 30 dias)")
        
        # Capital info
        if self.capital_manager:
            print(f"   üí∞ Capital: ${self.capital_manager.current_capital:.2f}")
            print(f"   üíº Position Size: ${self.capital_manager.get_position_size():.2f}")
        
        print(f"\\nüîß CONFIGURA√á√ÉO:")
        print("   1Ô∏è‚É£  Sele√ß√£o de Ativo")
        print("   2Ô∏è‚É£  Configura√ß√£o de Estrat√©gia")
        print("   3Ô∏è‚É£  Sele√ß√£o de Timeframe")
        print("   4Ô∏è‚É£  Per√≠odo Personalizado (Data Inicial/Final)")
        
        print(f"\\nüß™ TESTES:")
        print("   5Ô∏è‚É£  Teste Hist√≥rico (Backtest)")
        print("   6Ô∏è‚É£  Teste em Tempo Real")
        
        print(f"\\nüìä RESULTADOS:")
        print("   7Ô∏è‚É£  Visualizar Resultados")
        print("   8Ô∏è‚É£  Exportar Relat√≥rios")
        
        print(f"\\n   0Ô∏è‚É£  Voltar ao Menu Principal")
    
    def _asset_selection_menu(self):
        """Menu de sele√ß√£o de ativo"""
        print("\\nü™ô SELE√á√ÉO DE ATIVO")
        print("="*50)
        
        assets_list = list(self.available_assets.keys())
        for i, asset in enumerate(assets_list, 1):
            info = self.available_assets[asset]
            selected = "‚úÖ" if asset == self.selected_asset else "  "
            print(f"{selected} {i}. {info['emoji']} {asset} - {info['name']}")
        
        print("\\n0. Voltar")
        
        try:
            choice = int(input("\\nüî¢ Escolha um ativo: "))
            if 1 <= choice <= len(assets_list):
                self.selected_asset = assets_list[choice - 1]
                asset_info = self.available_assets[self.selected_asset]
                print(f"\\n‚úÖ Ativo selecionado: {asset_info['emoji']} {self.selected_asset} - {asset_info['name']}")
            elif choice == 0:
                return
            else:
                print("‚ùå Op√ß√£o inv√°lida")
        except ValueError:
            print("‚ùå Digite um n√∫mero v√°lido")
        
        input("\\nüìñ Pressione ENTER para continuar...")
    
    def _strategy_configuration_menu(self):
        """Menu de configura√ß√£o de estrat√©gia"""
        print("\\nüìà CONFIGURA√á√ÉO DE ESTRAT√âGIA")
        print("="*50)
        
        strategies_list = list(self.strategies.keys())
        for i, strategy_key in enumerate(strategies_list, 1):
            strategy = self.strategies[strategy_key]
            selected = "‚úÖ" if strategy_key == self.selected_strategy else "  "
            print(f"{selected} {i}. {strategy['emoji']} {strategy['name']}")
            print(f"      {strategy['description']} ({strategy['type']})")
        
        print("\\n0. Voltar")
        
        try:
            choice = int(input("\\nüî¢ Escolha uma estrat√©gia: "))
            if 1 <= choice <= len(strategies_list):
                strategy_key = strategies_list[choice - 1]
                self.selected_strategy = strategy_key
                strategy = self.strategies[strategy_key]
                print(f"\\n‚úÖ Estrat√©gia selecionada: {strategy['emoji']} {strategy['name']}")
                
                # Configurar par√¢metros
                self._configure_strategy_parameters(strategy_key)
            elif choice == 0:
                return
            else:
                print("‚ùå Op√ß√£o inv√°lida")
        except ValueError:
            print("‚ùå Digite um n√∫mero v√°lido")
        
        input("\\nüìñ Pressione ENTER para continuar...")
    
    def _configure_strategy_parameters(self, strategy_key: str):
        """Configura par√¢metros da estrat√©gia"""
        strategy = self.strategies[strategy_key]
        params = strategy['params']
        
        print(f"\\n‚öôÔ∏è CONFIGURA√á√ÉO DE PAR√ÇMETROS - {strategy['name']}")
        print("="*60)
        
        self.strategy_params[strategy_key] = {}
        
        for param_name, param_info in params.items():
            print(f"\\nüìä {param_info['description']}")
            print(f"   Valor padr√£o: {param_info['default']}")
            print(f"   Faixa: {param_info['min']} - {param_info['max']}")
            
            user_input = input(f"   Digite o valor (ENTER para padr√£o): ").strip()
            
            if user_input:
                try:
                    if isinstance(param_info['default'], float):
                        value = float(user_input)
                    else:
                        value = int(user_input)
                    
                    if param_info['min'] <= value <= param_info['max']:
                        self.strategy_params[strategy_key][param_name] = value
                        print(f"   ‚úÖ Valor definido: {value}")
                    else:
                        print(f"   ‚ùå Valor fora da faixa. Usando padr√£o: {param_info['default']}")
                        self.strategy_params[strategy_key][param_name] = param_info['default']
                except ValueError:
                    print(f"   ‚ùå Valor inv√°lido. Usando padr√£o: {param_info['default']}")
                    self.strategy_params[strategy_key][param_name] = param_info['default']
            else:
                self.strategy_params[strategy_key][param_name] = param_info['default']
                print(f"   ‚úÖ Usando valor padr√£o: {param_info['default']}")
    
    def _timeframe_selection_menu(self):
        """Menu de sele√ß√£o de timeframe"""
        print("\\n‚è∞ SELE√á√ÉO DE TIMEFRAME")
        print("="*50)
        
        timeframes_list = list(self.timeframes.keys())
        for i, tf_key in enumerate(timeframes_list, 1):
            tf_info = self.timeframes[tf_key]
            selected = "‚úÖ" if tf_key == self.selected_timeframe else "  "
            print(f"{selected} {i}. {tf_info['name']} - {tf_info['description']}")
        
        print("\\n0. Voltar")
        
        try:
            choice = int(input("\\nüî¢ Escolha um timeframe: "))
            if 1 <= choice <= len(timeframes_list):
                self.selected_timeframe = timeframes_list[choice - 1]
                tf_info = self.timeframes[self.selected_timeframe]
                print(f"\\n‚úÖ Timeframe selecionado: {tf_info['name']}")
            elif choice == 0:
                return
            else:
                print("‚ùå Op√ß√£o inv√°lida")
        except ValueError:
            print("‚ùå Digite um n√∫mero v√°lido")
        
        input("\\nüìñ Pressione ENTER para continuar...")
    
    def _period_selection_menu(self):
        """Menu de sele√ß√£o de per√≠odo personalizado"""
        print("\\nüìÖ PER√çODO PERSONALIZADO")
        print("="*50)
        
        print("1. Usar per√≠odo padr√£o (√∫ltimos 30 dias)")
        print("2. Definir per√≠odo personalizado")
        print("0. Voltar")
        
        choice = input("\\nüî¢ Escolha: ").strip()
        
        if choice == '1':
            self.custom_start_date = None
            self.custom_end_date = None
            print("‚úÖ Usando per√≠odo padr√£o (√∫ltimos 30 dias)")
        elif choice == '2':
            self._configure_custom_period()
        elif choice == '0':
            return
        else:
            print("‚ùå Op√ß√£o inv√°lida")
        
        input("\\nüìñ Pressione ENTER para continuar...")
    
    def _configure_custom_period(self):
        """Configura per√≠odo personalizado"""
        print("\\nüìÖ CONFIGURA√á√ÉO DE PER√çODO PERSONALIZADO")
        print("="*50)
        print("Formato: YYYY-MM-DD (ex: 2025-01-01)")
        
        try:
            start_date_str = input("\\nüìÖ Data inicial: ").strip()
            end_date_str = input("üìÖ Data final: ").strip()
            
            # Validar datas
            start_date = datetime.strptime(start_date_str, "%Y-%m-%d")
            end_date = datetime.strptime(end_date_str, "%Y-%m
