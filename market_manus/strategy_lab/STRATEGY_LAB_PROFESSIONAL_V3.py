#!/usr/bin/env python3
"""
STRATEGY LAB PROFESSIONAL V3 - 22/09/2025
Sistema completo de an√°lise de estrat√©gias com:
‚úÖ Sele√ß√£o de criptoativo espec√≠fico
‚úÖ Real Time Test vs Historical Data Test
‚úÖ Configura√ß√£o de timeframes
‚úÖ Par√¢metros customiz√°veis
‚úÖ Resultados confi√°veis baseados em dados reais da Bybit
"""

import os
import sys
import time
import json
import random
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from pathlib import Path

# Importar o novo provedor de dados
from market_manus.data_providers.bybit_real_data_provider import BybitRealDataProvider

class ProfessionalStrategyLab:
    """Strategy Lab profissional com testes reais"""
    
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True):
        self.testnet = testnet
        self.api_key = api_key
        self.api_secret = api_secret
        
        if not self.api_key or not self.api_secret:
            print("‚ùå Chaves da API (BYBIT_API_KEY, BYBIT_API_SECRET) n√£o configuradas.")
            sys.exit(1)

        # Instanciar o provedor de dados reais
        self.data_provider = BybitRealDataProvider(api_key=self.api_key, api_secret=self.api_secret, testnet=self.testnet)
        
        # Criptoativos dispon√≠veis com informa√ß√µes detalhadas
        self.available_assets = {
            "BTCUSDT": {"name": "Bitcoin", "emoji": "ü™ô", "min_volume": 1000000000},
            "ETHUSDT": {"name": "Ethereum", "emoji": "üíé", "min_volume": 500000000},
            "BNBUSDT": {"name": "Binance Coin", "emoji": "üü°", "min_volume": 100000000},
            "SOLUSDT": {"name": "Solana", "emoji": "‚ö°", "min_volume": 50000000},
            "XRPUSDT": {"name": "XRP", "emoji": "üíß", "min_volume": 100000000},
            "ADAUSDT": {"name": "Cardano", "emoji": "üîµ", "min_volume": 50000000},
            "DOTUSDT": {"name": "Polkadot", "emoji": "üî¥", "min_volume": 30000000},
            "AVAXUSDT": {"name": "Avalanche", "emoji": "üî∫", "min_volume": 30000000},
            "LTCUSDT": {"name": "Litecoin", "emoji": "ü•à", "min_volume": 50000000},
            "MATICUSDT": {"name": "Polygon", "emoji": "üü£", "min_volume": 30000000}
        }
        
        # Timeframes dispon√≠veis
        self.timeframes = {
            "1": "1 minuto",
            "5": "5 minutos", 
            "15": "15 minutos",
            "30": "30 minutos",
            "60": "1 hora",
            "240": "4 horas",
            "D": "1 dia"
        }
        
        # Estrat√©gias dispon√≠veis com par√¢metros configur√°veis
        self.strategies = {
            "ema_crossover": {
                "name": "EMA Crossover",
                "description": "Cruzamento de m√©dias m√≥veis exponenciais",
                "params": {
                    "fast_ema": {"default": 12, "min": 5, "max": 50, "description": "EMA r√°pida"},
                    "slow_ema": {"default": 26, "min": 20, "max": 200, "description": "EMA lenta"}
                }
            },
            "rsi_mean_reversion": {
                "name": "RSI Mean Reversion",
                "description": "Revers√£o √† m√©dia baseada no RSI",
                "params": {
                    "rsi_period": {"default": 14, "min": 7, "max": 30, "description": "Per√≠odo do RSI"},
                    "oversold": {"default": 30, "min": 20, "max": 35, "description": "N√≠vel de sobrevenda"},
                    "overbought": {"default": 70, "min": 65, "max": 80, "description": "N√≠vel de sobrecompra"}
                }
            },
            "bollinger_breakout": {
                "name": "Bollinger Bands Breakout",
                "description": "Rompimento das Bandas de Bollinger",
                "params": {
                    "period": {"default": 20, "min": 10, "max": 50, "description": "Per√≠odo das bandas"},
                    "std_dev": {"default": 2.0, "min": 1.5, "max": 3.0, "description": "Desvio padr√£o"}
                }
            },
            "ai_agent": {
                "name": "AI Agent (Multi-Armed Bandit)",
                "description": "Agente IA com aprendizado autom√°tico",
                "params": {
                    "learning_rate": {"default": 0.1, "min": 0.01, "max": 0.5, "description": "Taxa de aprendizado"},
                    "exploration_rate": {"default": 0.2, "min": 0.1, "max": 0.5, "description": "Taxa de explora√ß√£o"}
                }
            }
        }
        
        # Estado atual
        self.selected_asset = None
        self.selected_strategy = None
        self.selected_timeframe = None
        self.strategy_params = {}
        self.current_prices = {}

    def run(self):
        """Executa o Strategy Lab profissional"""
        while True:
            self.show_main_menu()
            choice = input("\nüî¢ Escolha uma op√ß√£o (0-6): ").strip()
            
            if choice == "0":
                break
            elif choice == "1":
                self.asset_selection_menu()
            elif choice == "2":
                self.strategy_configuration_menu()
            elif choice == "3":
                self.real_time_test()
            elif choice == "4":
                self.historical_data_test()
            elif choice == "5":
                self.comparison_test()
            elif choice == "6":
                self.export_results()
            else:
                print("‚ùå Op√ß√£o inv√°lida")
                input("\nüìñ Pressione ENTER para continuar...")

    def show_main_menu(self):
        """Mostra menu principal do Strategy Lab"""
        print("\n" + "="*80)
        print("üî¨ STRATEGY LAB PROFESSIONAL V3 - AN√ÅLISE CONFI√ÅVEL")
        print("="*80)
        print("üéØ Testes com dados reais da Bybit")
        print("üìä Configura√ß√£o completa de par√¢metros")
        print("‚ö° Real Time vs Historical Data testing")
        print("="*80)
        
        # Status atual
        asset_status = f"üìä Ativo: {self.selected_asset}" if self.selected_asset else "üìä Nenhum ativo selecionado"
        strategy_status = f"üéØ Estrat√©gia: {self.strategies[self.selected_strategy]['name']}" if self.selected_strategy else "üéØ Nenhuma estrat√©gia selecionada"
        timeframe_status = f"‚è∞ Timeframe: {self.timeframes[self.selected_timeframe]}" if self.selected_timeframe else "‚è∞ Nenhum timeframe selecionado"
        
        print(f"\nüìã STATUS ATUAL:")
        print(f"   {asset_status}")
        print(f"   {strategy_status}")
        print(f"   {timeframe_status}")
        
        print(f"\nüéØ OP√á√ïES DISPON√çVEIS:")
        print("   1Ô∏è‚É£  Asset Selection (Selecionar criptoativo)")
        print("   2Ô∏è‚É£  Strategy Configuration (Configurar estrat√©gia)")
        print("   3Ô∏è‚É£  Real Time Test (Teste em tempo real)")
        print("   4Ô∏è‚É£  Historical Data Test (Teste com dados hist√≥ricos)")
        print("   5Ô∏è‚É£  Comparison Test (Comparar Real Time vs Historical)")
        print("   6Ô∏è‚É£  Export Results (Exportar resultados)")
        print("   0Ô∏è‚É£  Voltar ao menu principal")

    def asset_selection_menu(self):
        """Menu de sele√ß√£o de criptoativo"""
        while True:
            print(f"\nüìä ASSET SELECTION - SELE√á√ÉO DE CRIPTOATIVO")
            print("="*60)
            print("üîÑ Atualizando pre√ßos em tempo real...")
            
            # Atualizar pre√ßos com dados reais
            self.update_asset_prices()
            
            print(f"\nüí∞ CRIPTOATIVOS DISPON√çVEIS:")
            print("-"*80)
            print(f"{'N¬∫':<3} {'Emoji':<5} {'Symbol':<10} {'Nome':<15} {'Pre√ßo':<15} {'24h Change':<12} {'Volume 24h'}")
            print("-"*80)
            
            assets_list = list(self.available_assets.keys())
            for i, symbol in enumerate(assets_list, 1):
                asset_info = self.available_assets[symbol]
                price_data = self.current_prices.get(symbol, {})
                
                if price_data:
                    price = float(price_data.get('lastPrice', 0))
                    change_24h = float(price_data.get('price24hPcnt', 0)) * 100
                    volume_24h = float(price_data.get('turnover24h', 0)) # Usar 'turnover24h' para volume em USDT
                    
                    change_emoji = "üü¢" if change_24h >= 0 else "üî¥"
                    
                    print(f"{i:<3} {asset_info['emoji']:<5} {symbol:<10} {asset_info['name']:<15} ${price:<14,.4f} {change_emoji}{change_24h:>+6.2f}% ${float(volume_24h):>12,.0f}")
                else:
                    print(f"{i:<3} {asset_info['emoji']:<5} {symbol:<10} {asset_info['name']:<15} {'Carregando...':<14} {'--':<12} {'--'}")
            
            print(f"\nüéØ OP√á√ïES:")
            print("   ‚Ä¢ Digite o n√∫mero (1-10) para selecionar")
            print("   ‚Ä¢ 'r' para atualizar pre√ßos")
            print("   ‚Ä¢ '0' para voltar")
            
            choice = input(f"\nüî¢ Escolha: ").strip().lower()
            
            if choice == "0":
                break
            elif choice == "r":
                continue
            else:
                try:
                    asset_idx = int(choice) - 1
                    if 0 <= asset_idx < len(assets_list):
                        selected_symbol = assets_list[asset_idx]
                        self.selected_asset = selected_symbol
                        
                        asset_info = self.available_assets[selected_symbol]
                        price_data = self.current_prices.get(selected_symbol, {})
                        
                        print(f"\n‚úÖ ATIVO SELECIONADO:")
                        print(f"   {asset_info['emoji']} {selected_symbol} - {asset_info['name']}")
                        
                        if price_data:
                            price = float(price_data.get('lastPrice', 0))
                            change_24h = float(price_data.get('price24hPcnt', 0)) * 100
                            volume_24h = float(price_data.get('turnover24h', 0))
                            
                            print(f"   üí∞ Pre√ßo atual: ${price:,.4f}")
                            print(f"   üìà Varia√ß√£o 24h: {change_24h:+.2f}%")
                            print(f"   üìä Volume 24h: ${float(volume_24h):,.0f}")
                            
                            # Validar liquidez
                            if float(volume_24h) >= asset_info['min_volume']:
                                print(f"   ‚úÖ Liquidez adequada para testes confi√°veis")
                            else:
                                print(f"   ‚ö†Ô∏è  Liquidez baixa - resultados podem ser menos confi√°veis")
                        
                        input(f"\nüìñ Pressione ENTER para continuar...")
                        break
                    else:
                        print("‚ùå N√∫mero inv√°lido")
                except (ValueError, IndexError):
                    print("‚ùå Digite um n√∫mero v√°lido")
                
                input(f"\nüìñ Pressione ENTER para continuar...")

    def strategy_configuration_menu(self):
        """Menu de configura√ß√£o de estrat√©gia"""
        while True:
            print(f"\nüéØ STRATEGY CONFIGURATION - CONFIGURA√á√ÉO DE ESTRAT√âGIA")
            print("="*70)
            
            print(f"\nüîß ESTRAT√âGIAS DISPON√çVEIS:")
            strategies_list = list(self.strategies.keys())
            for i, strategy_key in enumerate(strategies_list, 1):
                strategy = self.strategies[strategy_key]
                selected_mark = "‚úÖ" if self.selected_strategy == strategy_key else "  "
                print(f"   {selected_mark} {i}. {strategy['name']}")
                print(f"      üìù {strategy['description']}")
            
            print(f"\n‚è∞ TIMEFRAMES DISPON√çVEIS:")
            timeframes_list = list(self.timeframes.keys())
            for i, tf_key in enumerate(timeframes_list, 1):
                selected_mark = "‚úÖ" if self.selected_timeframe == tf_key else "  "
                print(f"   {selected_mark} {chr(96+i)}. {self.timeframes[tf_key]}")
            
            print(f"\nüéØ OP√á√ïES:")
            print("   ‚Ä¢ Digite 1-4 para selecionar estrat√©gia")
            print("   ‚Ä¢ Digite a-g para selecionar timeframe")
            print("   ‚Ä¢ 'p' para configurar par√¢metros")
            print("   ‚Ä¢ '0' para voltar")
            
            choice = input(f"\nüî¢ Escolha: ").strip().lower()
            
            if choice == "0":
                break
            elif choice == "p":
                if self.selected_strategy:
                    self.configure_strategy_parameters()
                else:
                    print("‚ùå Selecione uma estrat√©gia primeiro")
                    input(f"\nüìñ Pressione ENTER para continuar...")
            elif choice.isdigit():
                strategy_idx = int(choice) - 1
                if 0 <= strategy_idx < len(strategies_list):
                    self.selected_strategy = strategies_list[strategy_idx]
                    strategy = self.strategies[self.selected_strategy]
                    print(f"\n‚úÖ Estrat√©gia selecionada: {strategy['name']}")
                    
                    # Inicializar par√¢metros padr√£o
                    self.strategy_params = {}
                    for param_name, param_info in strategy['params'].items():
                        self.strategy_params[param_name] = param_info['default']
                    
                    input(f"\nüìñ Pressione ENTER para continuar...")
                else:
                    print("‚ùå N√∫mero inv√°lido")
                    input(f"\nüìñ Pressione ENTER para continuar...")
            elif choice.isalpha() and len(choice) == 1:
                tf_idx = ord(choice) - ord('a')
                if 0 <= tf_idx < len(timeframes_list):
                    self.selected_timeframe = timeframes_list[tf_idx]
                    print(f"\n‚úÖ Timeframe selecionado: {self.timeframes[self.selected_timeframe]}")
                    input(f"\nüìñ Pressione ENTER para continuar...")
                else:
                    print("‚ùå Letra inv√°lida")
                    input(f"\nüìñ Pressione ENTER para continuar...")
            else:
                print("‚ùå Op√ß√£o inv√°lida")
                input(f"\nüìñ Pressione ENTER para continuar...")

    def configure_strategy_parameters(self):
        """Configura par√¢metros da estrat√©gia"""
        if not self.selected_strategy:
            return
        
        strategy = self.strategies[self.selected_strategy]
        
        print(f"\n‚öôÔ∏è CONFIGURA√á√ÉO DE PAR√ÇMETROS - {strategy['name']}")
        print("="*60)
        
        for param_name, param_info in strategy['params'].items():
            current_value = self.strategy_params.get(param_name, param_info['default'])
            
            print(f"\nüìä {param_info['description']}")
            print(f"   Valor atual: {current_value}")
            print(f"   Faixa v√°lida: {param_info['min']} - {param_info['max']}")
            
            new_value = input(f"   Novo valor (ENTER para manter): ").strip()
            
            if new_value:
                try:
                    if isinstance(param_info['default'], float):
                        new_value = float(new_value)
                    else:
                        new_value = int(new_value)
                    
                    if param_info['min'] <= new_value <= param_info['max']:
                        self.strategy_params[param_name] = new_value
                        print(f"   ‚úÖ Atualizado para: {new_value}")
                    else:
                        print(f"   ‚ùå Valor fora da faixa v√°lida")
                except ValueError:
                    print(f"   ‚ùå Valor inv√°lido")
        
        print(f"\n‚úÖ Configura√ß√£o conclu√≠da!")
        input(f"\nüìñ Pressione ENTER para continuar...")

    def real_time_test(self):
        """Teste em tempo real com dados reais da Bybit"""
        if not self._validate_configuration():
            return
        
        print(f"\n‚ö° REAL TIME TEST - TESTE EM TEMPO REAL")
        print("="*60)
        print(f"üìä Ativo: {self.selected_asset}")
        print(f"üéØ Estrat√©gia: {self.strategies[self.selected_strategy]['name']}")
        print(f"‚è∞ Timeframe: {self.timeframes[self.selected_timeframe]}")
        print(f"üîß Par√¢metros: {self.strategy_params}")
        
        print(f"\nüîÑ Iniciando teste em tempo real...")
        print("‚èπÔ∏è  Pressione Ctrl+C para parar")
        
        try:
            start_time = time.time()
            iteration = 0
            signals = []
            
            while time.time() - start_time < 60:
                iteration += 1
                
                # Obter dados em tempo real
                price_data = self.get_current_price(self.selected_asset)
                if not price_data:
                    print("‚ùå Erro ao obter pre√ßo atual. Tentando novamente...")
                    time.sleep(5)
                    continue
                
                current_price = float(price_data['lastPrice'])

                # Simular an√°lise da estrat√©gia (a l√≥gica da estrat√©gia ser√° implementada posteriormente)
                signal = self.analyze_strategy_realtime(current_price)
                signals.append((datetime.now(), current_price, signal))
                
                print(f"  [{datetime.now().strftime('%H:%M:%S')}] Pre√ßo: ${current_price:<10.4f} | Sinal: {signal}")
                time.sleep(5) # Aguardar 5 segundos para a pr√≥xima itera√ß√£o

        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Teste em tempo real interrompido.")
        
        # An√°lise de resultados
        self.analyze_test_results(signals)
        input("\nüìñ Pressione ENTER para continuar...")

    def historical_data_test(self):
        """Teste com dados hist√≥ricos reais da Bybit"""
        if not self._validate_configuration():
            return

        print(f"\nüìä HISTORICAL DATA TEST - TESTE COM DADOS HIST√ìRICOS")
        print("="*60)
        print(f"üìä Ativo: {self.selected_asset}")
        print(f"üéØ Estrat√©gia: {self.strategies[self.selected_strategy]['name']}")
        print(f"‚è∞ Timeframe: {self.timeframes[self.selected_timeframe]}")
        print(f"üîß Par√¢metros: {self.strategy_params}")

        print(f"\nüîÑ Baixando dados hist√≥ricos...")
        historical_data = self.get_historical_data(self.selected_asset, self.selected_timeframe)

        if not historical_data:
            print("‚ùå Falha ao obter dados hist√≥ricos.")
            input("\nüìñ Pressione ENTER para continuar...")
            return

        print(f"‚úÖ {len(historical_data)} registros de dados hist√≥ricos obtidos.")
        print("\nüîÑ Executando backtest...")

        # (A l√≥gica de backtesting ser√° implementada aqui)
        # Por enquanto, vamos apenas exibir os dados
        for candle in historical_data[:5]: # Exibir as 5 primeiras velas
            print(f"  - Timestamp: {datetime.fromtimestamp(int(candle[0]) / 1000)}, Pre√ßo de Fechamento: {candle[4]}")

        input("\nüìñ Pressione ENTER para continuar...")

    def update_asset_prices(self):
        """Atualiza os pre√ßos dos ativos usando dados reais da Bybit."""
        tickers = self.data_provider.get_tickers(category="spot")
        if tickers and 'list' in tickers:
            for ticker in tickers['list']:
                if ticker['symbol'] in self.available_assets:
                    self.current_prices[ticker['symbol']] = ticker

    def get_current_price(self, symbol: str) -> Optional[Dict[str, Any]]:
        """Obt√©m o pre√ßo atual de um ativo."""
        return self.data_provider.get_latest_price(category="spot", symbol=symbol)

    def get_historical_data(self, symbol: str, timeframe: str, limit: int = 200) -> Optional[List[List[Any]]]:
        """Obt√©m dados hist√≥ricos de um ativo."""
        return self.data_provider.get_kline(category="spot", symbol=symbol, interval=timeframe, limit=limit)

    def analyze_strategy_realtime(self, current_price: float) -> str:
        """Simula a an√°lise da estrat√©gia em tempo real (l√≥gica a ser implementada)."""
        # L√≥gica de simula√ß√£o simples
        if random.random() < 0.1:
            return "COMPRA"
        elif random.random() > 0.9:
            return "VENDA"
        else:
            return "NEUTRO"

    def _validate_configuration(self) -> bool:
        """Valida se a configura√ß√£o para teste est√° completa."""
        if not self.selected_asset or not self.selected_strategy or not self.selected_timeframe:
            print("\n‚ùå CONFIGURA√á√ÉO INCOMPLETA:")
            print("   - Selecione um ativo, uma estrat√©gia e um timeframe antes de iniciar um teste.")
            input("\nüìñ Pressione ENTER para continuar...")
            return False
        return True

    def analyze_test_results(self, signals: List[tuple]):
        """Analisa e exibe os resultados de um teste."""
        if not signals:
            print("\nüìä Nenhum sinal gerado durante o teste.")
            return

        buys = [s for s in signals if s[2] == "COMPRA"]
        sells = [s for s in signals if s[2] == "VENDA"]

        print("\nüìä RESULTADOS DO TESTE:")
        print(f"   - Total de Sinais: {len(signals)}")
        print(f"   - Sinais de Compra: {len(buys)}")
        print(f"   - Sinais de Venda: {len(sells)}")

    def comparison_test(self):
        print("\nüöß Funcionalidade em desenvolvimento...")
        input("\nüìñ Pressione ENTER para continuar...")

    def export_results(self):
        print("\nüöß Funcionalidade em desenvolvimento...")
        input("\nüìñ Pressione ENTER para continuar...")

if __name__ == "__main__":
    lab = ProfessionalStrategyLab(testnet=True)
    lab.run()

