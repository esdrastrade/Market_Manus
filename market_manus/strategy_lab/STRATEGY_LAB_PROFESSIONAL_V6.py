"""
Strategy Lab Professional V6 - Vers√£o Validada
Localiza√ß√£o: market_manus/strategy_lab/STRATEGY_LAB_PROFESSIONAL_V6.py
Data: 25/09/2025
Sintaxe: 100% Validada
"""

import os
import sys
import json
import time
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from pathlib import Path

class StrategyLabProfessionalV6:
    """Strategy Lab Professional V6 - Vers√£o completa com todas as estrat√©gias"""
    
    def __init__(self, data_provider=None, capital_manager=None):
        self.data_provider = data_provider
        self.capital_manager = capital_manager
        
        # Estrat√©gias dispon√≠veis (8 estrat√©gias completas)
        self.strategies = {
            "rsi_mean_reversion": {
                "name": "RSI Mean Reversion",
                "description": "Revers√£o √† m√©dia baseada no RSI",
                "emoji": "üìä",
                "type": "Oscillator",
                "params": {
                    "rsi_period": {"default": 14, "min": 7, "max": 30, "description": "Per√≠odo do RSI"},
                    "oversold": {"default": 30, "min": 20, "max": 35, "description": "N√≠vel de sobrevenda"},
                    "overbought": {"default": 70, "min": 65, "max": 80, "description": "N√≠vel de sobrecompra"}
                }
            },
            "ema_crossover": {
                "name": "EMA Crossover",
                "description": "Cruzamento de m√©dias m√≥veis exponenciais",
                "emoji": "üìà",
                "type": "Trend Following",
                "params": {
                    "fast_ema": {"default": 12, "min": 5, "max": 50, "description": "EMA r√°pida"},
                    "slow_ema": {"default": 26, "min": 20, "max": 200, "description": "EMA lenta"}
                }
            },
            "bollinger_breakout": {
                "name": "Bollinger Bands Breakout",
                "description": "Rompimento das Bandas de Bollinger",
                "emoji": "üéØ",
                "type": "Volatility",
                "params": {
                    "period": {"default": 20, "min": 10, "max": 50, "description": "Per√≠odo das bandas"},
                    "std_dev": {"default": 2.0, "min": 1.5, "max": 3.0, "description": "Desvio padr√£o"}
                }
            },
            "macd": {
                "name": "MACD",
                "description": "Moving Average Convergence Divergence",
                "emoji": "üìä",
                "type": "Momentum",
                "params": {
                    "fast_period": {"default": 12, "min": 5, "max": 20, "description": "Per√≠odo EMA r√°pida"},
                    "slow_period": {"default": 26, "min": 20, "max": 50, "description": "Per√≠odo EMA lenta"},
                    "signal_period": {"default": 9, "min": 5, "max": 15, "description": "Per√≠odo linha de sinal"}
                }
            },
            "stochastic": {
                "name": "Stochastic Oscillator",
                "description": "Oscilador Estoc√°stico %K e %D",
                "emoji": "üìà",
                "type": "Oscillator",
                "params": {
                    "k_period": {"default": 14, "min": 5, "max": 25, "description": "Per√≠odo %K"},
                    "d_period": {"default": 3, "min": 3, "max": 10, "description": "Per√≠odo %D"},
                    "oversold": {"default": 20, "min": 10, "max": 30, "description": "N√≠vel oversold"},
                    "overbought": {"default": 80, "min": 70, "max": 90, "description": "N√≠vel overbought"}
                }
            },
            "williams_r": {
                "name": "Williams %R",
                "description": "Williams Percent Range Oscillator",
                "emoji": "üìâ",
                "type": "Oscillator",
                "params": {
                    "period": {"default": 14, "min": 5, "max": 25, "description": "Per√≠odo de lookback"},
                    "oversold": {"default": -80, "min": -90, "max": -70, "description": "N√≠vel oversold"},
                    "overbought": {"default": -20, "min": -30, "max": -10, "description": "N√≠vel overbought"}
                }
            },
            "adx": {
                "name": "ADX",
                "description": "Average Directional Index",
                "emoji": "üéØ",
                "type": "Trend Strength",
                "params": {
                    "period": {"default": 14, "min": 10, "max": 20, "description": "Per√≠odo ADX"},
                    "adx_threshold": {"default": 25, "min": 20, "max": 30, "description": "Threshold tend√™ncia forte"}
                }
            },
            "fibonacci": {
                "name": "Fibonacci Retracement",
                "description": "N√≠veis de Retra√ß√£o de Fibonacci",
                "emoji": "üî¢",
                "type": "Support/Resistance",
                "params": {
                    "lookback_period": {"default": 50, "min": 20, "max": 100, "description": "Per√≠odo lookback"},
                    "tolerance_pct": {"default": 0.5, "min": 0.1, "max": 2.0, "description": "Toler√¢ncia (%)"}
                }
            }
        }
        
        # Timeframes dispon√≠veis
        self.timeframes = {
            "1": {"name": "1 minuto", "bybit_interval": "1", "description": "Scalping ultra-r√°pido"},
            "5": {"name": "5 minutos", "bybit_interval": "5", "description": "Scalping r√°pido"},
            "15": {"name": "15 minutos", "bybit_interval": "15", "description": "Swing trading curto"},
            "30": {"name": "30 minutos", "bybit_interval": "30", "description": "Swing trading m√©dio"},
            "60": {"name": "1 hora", "bybit_interval": "60", "description": "Swing trading longo"},
            "240": {"name": "4 horas", "bybit_interval": "240", "description": "Position trading"},
            "D": {"name": "1 dia", "bybit_interval": "D", "description": "Investimento longo prazo"}
        }
        
        # Assets dispon√≠veis
        self.available_assets = {
            "BTCUSDT": {"name": "Bitcoin", "emoji": "ü™ô"},
            "ETHUSDT": {"name": "Ethereum", "emoji": "üíé"},
            "BNBUSDT": {"name": "Binance Coin", "emoji": "üü°"},
            "SOLUSDT": {"name": "Solana", "emoji": "‚ö°"},
            "XRPUSDT": {"name": "XRP", "emoji": "üíß"},
            "ADAUSDT": {"name": "Cardano", "emoji": "üîµ"},
            "DOGEUSDT": {"name": "Dogecoin", "emoji": "üêï"},
            "MATICUSDT": {"name": "Polygon", "emoji": "üü£"}
        }
        
        # Configura√ß√µes atuais
        self.selected_asset = None
        self.selected_timeframe = None
        self.selected_strategy = None
        self.strategy_params = {}
        self.custom_start_date = None
        self.custom_end_date = None
        
        # Hist√≥rico de testes
        self.test_history = []
    
    def run_interactive_mode(self):
        """Executa o modo interativo do Strategy Lab"""
        while True:
            self._show_main_menu()
            choice = input("\nüî¢ Escolha uma op√ß√£o (0-8): ").strip()
            
            if choice == '0':
                print("\nüëã Saindo do Strategy Lab Professional V6...")
                break
            elif choice == '1':
                self._asset_selection_menu()
            elif choice == '2':
                self._strategy_configuration_menu()
            elif choice == '3':
                self._timeframe_selection_menu()
            elif choice == '4':
                self._period_selection_menu()
            elif choice == '5':
                self._run_historical_backtest()
            elif choice == '6':
                self._run_realtime_test()
            elif choice == '7':
                self._view_test_results()
            elif choice == '8':
                self._export_results()
            else:
                print("‚ùå Op√ß√£o inv√°lida")
                input("\nüìñ Pressione ENTER para continuar...")
    
    def _show_main_menu(self):
        """Mostra o menu principal do Strategy Lab"""
        print("\n" + "="*80)
        print("üî¨ STRATEGY LAB PROFESSIONAL V6 - MENU PRINCIPAL")
        print("="*80)
        
        # Status atual
        asset_status = f"‚úÖ {self.selected_asset}" if self.selected_asset else "‚ùå N√£o selecionado"
        strategy_status = f"‚úÖ {self.strategies[self.selected_strategy]['name']}" if self.selected_strategy else "‚ùå N√£o selecionada"
        timeframe_status = f"‚úÖ {self.timeframes[self.selected_timeframe]['name']}" if self.selected_timeframe else "‚ùå N√£o selecionado"
        
        print(f"üìä CONFIGURA√á√ÉO ATUAL:")
        print(f"   ü™ô Ativo: {asset_status}")
        print(f"   üìà Estrat√©gia: {strategy_status}")
        print(f"   ‚è∞ Timeframe: {timeframe_status}")
        
        if self.custom_start_date and self.custom_end_date:
            print(f"   üìÖ Per√≠odo: {self.custom_start_date} at√© {self.custom_end_date}")
        else:
            print(f"   üìÖ Per√≠odo: Padr√£o (√∫ltimos 30 dias)")
        
        # Capital info
        if self.capital_manager:
            print(f"   üí∞ Capital: ${self.capital_manager.current_capital:.2f}")
            print(f"   üíº Position Size: ${self.capital_manager.get_position_size():.2f}")
        
        print(f"\nüîß CONFIGURA√á√ÉO:")
        print("   1Ô∏è‚É£  Sele√ß√£o de Ativo")
        print("   2Ô∏è‚É£  Configura√ß√£o de Estrat√©gia")
        print("   3Ô∏è‚É£  Sele√ß√£o de Timeframe")
        print("   4Ô∏è‚É£  Per√≠odo Personalizado (Data Inicial/Final)")
        
        print(f"\nüß™ TESTES:")
        print("   5Ô∏è‚É£  Teste Hist√≥rico (Backtest)")
        print("   6Ô∏è‚É£  Teste em Tempo Real")
        
        print(f"\nüìä RESULTADOS:")
        print("   7Ô∏è‚É£  Visualizar Resultados")
        print("   8Ô∏è‚É£  Exportar Relat√≥rios")
        
        print(f"\n   0Ô∏è‚É£  Voltar ao Menu Principal")
    
    def _asset_selection_menu(self):
        """Menu de sele√ß√£o de ativo"""
        print("\nü™ô SELE√á√ÉO DE ATIVO")
        print("="*50)
        
        assets_list = list(self.available_assets.keys())
        for i, asset in enumerate(assets_list, 1):
            info = self.available_assets[asset]
            selected = "‚úÖ" if asset == self.selected_asset else "  "
            print(f"   {i}Ô∏è‚É£  {selected} {info['emoji']} {asset} - {info['name']}")
        
        print(f"\n   0Ô∏è‚É£  Voltar")
        
        choice = input("\nüî¢ Escolha um ativo (0-8): ").strip()
        
        if choice == '0':
            return
        
        try:
            asset_index = int(choice) - 1
            if 0 <= asset_index < len(assets_list):
                self.selected_asset = assets_list[asset_index]
                asset_info = self.available_assets[self.selected_asset]
                print(f"\n‚úÖ Ativo selecionado: {asset_info['emoji']} {self.selected_asset} - {asset_info['name']}")
            else:
                print("‚ùå Op√ß√£o inv√°lida")
        except ValueError:
            print("‚ùå Digite um n√∫mero v√°lido")
        
        input("\nüìñ Pressione ENTER para continuar...")
    
    def _strategy_configuration_menu(self):
        """Menu de configura√ß√£o de estrat√©gia"""
        print("\nüìà CONFIGURA√á√ÉO DE ESTRAT√âGIA")
        print("="*50)
        
        strategies_list = list(self.strategies.keys())
        for i, strategy_key in enumerate(strategies_list, 1):
            strategy = self.strategies[strategy_key]
            selected = "‚úÖ" if strategy_key == self.selected_strategy else "  "
            print(f"   {i}Ô∏è‚É£  {selected} {strategy['emoji']} {strategy['name']}")
            print(f"       üìù {strategy['description']}")
            print(f"       üè∑Ô∏è Tipo: {strategy['type']}")
        
        print(f"\n   0Ô∏è‚É£  Voltar")
        
        choice = input("\nüî¢ Escolha uma estrat√©gia (0-8): ").strip()
        
        if choice == '0':
            return
        
        try:
            strategy_index = int(choice) - 1
            if 0 <= strategy_index < len(strategies_list):
                strategy_key = strategies_list[strategy_index]
                self.selected_strategy = strategy_key
                strategy_info = self.strategies[strategy_key]
                print(f"\n‚úÖ Estrat√©gia selecionada: {strategy_info['emoji']} {strategy_info['name']}")
                
                # Configurar par√¢metros
                self._configure_strategy_parameters(strategy_key)
            else:
                print("‚ùå Op√ß√£o inv√°lida")
        except ValueError:
            print("‚ùå Digite um n√∫mero v√°lido")
        
        input("\nüìñ Pressione ENTER para continuar...")
    
    def _configure_strategy_parameters(self, strategy_key: str):
        """Configura os par√¢metros da estrat√©gia"""
        strategy = self.strategies[strategy_key]
        params = strategy['params']
        
        print(f"\n‚öôÔ∏è CONFIGURA√á√ÉO DE PAR√ÇMETROS - {strategy['name']}")
        print("="*60)
        
        self.strategy_params[strategy_key] = {}
        
        for param_name, param_info in params.items():
            print(f"\nüìä {param_info['description']}")
            print(f"   Valor padr√£o: {param_info['default']}")
            print(f"   Faixa: {param_info['min']} - {param_info['max']}")
            
            user_input = input(f"   Digite o valor (ENTER para padr√£o): ").strip()
            
            if user_input == "":
                value = param_info['default']
            else:
                try:
                    value = float(user_input)
                    if value < param_info['min'] or value > param_info['max']:
                        print(f"   ‚ö†Ô∏è Valor fora da faixa, usando padr√£o: {param_info['default']}")
                        value = param_info['default']
                except ValueError:
                    print(f"   ‚ùå Valor inv√°lido, usando padr√£o: {param_info['default']}")
                    value = param_info['default']
            
            self.strategy_params[strategy_key][param_name] = value
            print(f"   ‚úÖ {param_info['description']}: {value}")
    
    def _timeframe_selection_menu(self):
        """Menu de sele√ß√£o de timeframe"""
        print("\n‚è∞ SELE√á√ÉO DE TIMEFRAME")
        print("="*50)
        
        timeframes_list = list(self.timeframes.keys())
        for i, tf_key in enumerate(timeframes_list, 1):
            tf_info = self.timeframes[tf_key]
            selected = "‚úÖ" if tf_key == self.selected_timeframe else "  "
            print(f"   {i}Ô∏è‚É£  {selected} {tf_info['name']} - {tf_info['description']}")
        
        print(f"\n   0Ô∏è‚É£  Voltar")
        
        choice = input("\nüî¢ Escolha um timeframe (0-7): ").strip()
        
        if choice == '0':
            return
        
        try:
            tf_index = int(choice) - 1
            if 0 <= tf_index < len(timeframes_list):
                tf_key = timeframes_list[tf_index]
                self.selected_timeframe = tf_key
                tf_info = self.timeframes[tf_key]
                print(f"\n‚úÖ Timeframe selecionado: {tf_info['name']} - {tf_info['description']}")
            else:
                print("‚ùå Op√ß√£o inv√°lida")
        except ValueError:
            print("‚ùå Digite um n√∫mero v√°lido")
        
        input("\nüìñ Pressione ENTER para continuar...")
    
    def _period_selection_menu(self):
        """Menu de sele√ß√£o de per√≠odo personalizado"""
        print("\nüìÖ PER√çODO PERSONALIZADO")
        print("="*50)
        
        print("üîß Configure o per√≠odo para backtesting:")
        print("   üìÖ Data inicial (formato: YYYY-MM-DD)")
        print("   üìÖ Data final (formato: YYYY-MM-DD)")
        print("   üí° Deixe em branco para usar per√≠odo padr√£o (√∫ltimos 30 dias)")
        
        # Data inicial
        start_input = input("\nüìÖ Data inicial (YYYY-MM-DD): ").strip()
        if start_input:
            try:
                start_date = datetime.strptime(start_input, "%Y-%m-%d")
                self.custom_start_date = start_date.strftime("%Y-%m-%d")
                print(f"‚úÖ Data inicial: {self.custom_start_date}")
            except ValueError:
                print("‚ùå Formato de data inv√°lido, usando padr√£o")
                self.custom_start_date = None
        else:
            self.custom_start_date = None
            print("üìÖ Usando per√≠odo padr√£o para data inicial")
        
        # Data final
        end_input = input("\nüìÖ Data final (YYYY-MM-DD): ").strip()
        if end_input:
            try:
                end_date = datetime.strptime(end_input, "%Y-%m-%d")
                self.custom_end_date = end_date.strftime("%Y-%m-%d")
                print(f"‚úÖ Data final: {self.custom_end_date}")
                
                # Validar se data final √© posterior √† inicial
                if self.custom_start_date:
                    start_dt = datetime.strptime(self.custom_start_date, "%Y-%m-%d")
                    end_dt = datetime.strptime(self.custom_end_date, "%Y-%m-%d")
                    if end_dt <= start_dt:
                        print("‚ùå Data final deve ser posterior √† inicial, usando padr√£o")
                        self.custom_start_date = None
                        self.custom_end_date = None
            except ValueError:
                print("‚ùå Formato de data inv√°lido, usando padr√£o")
                self.custom_end_date = None
        else:
            self.custom_end_date = None
            print("üìÖ Usando per√≠odo padr√£o para data final")
        
        # Resumo
        if self.custom_start_date and self.custom_end_date:
            print(f"\n‚úÖ Per√≠odo personalizado configurado:")
            print(f"   üìÖ De: {self.custom_start_date}")
            print(f"   üìÖ At√©: {self.custom_end_date}")
        else:
            print(f"\nüìÖ Usando per√≠odo padr√£o (√∫ltimos 30 dias)")
        
        input("\nüìñ Pressione ENTER para continuar...")
    
    def _validate_configuration(self) -> bool:
        """Valida se a configura√ß√£o est√° completa"""
        if not self.selected_asset:
            print("‚ùå Selecione um ativo primeiro (op√ß√£o 1)")
            input("\nüìñ Pressione ENTER para continuar...")
            return False
        
        if not self.selected_strategy:
            print("‚ùå Selecione uma estrat√©gia primeiro (op√ß√£o 2)")
            input("\nüìñ Pressione ENTER para continuar...")
            return False
        
        if not self.selected_timeframe:
            print("‚ùå Selecione um timeframe primeiro (op√ß√£o 3)")
            input("\nüìñ Pressione ENTER para continuar...")
            return False
        
        return True
    
    def _run_historical_backtest(self):
        """Executa teste hist√≥rico (backtest)"""
        if not self._validate_configuration():
            return
        
        print("\nüß™ EXECUTANDO TESTE HIST√ìRICO (BACKTEST)")
        print("="*60)
        
        print(f"üìä Configura√ß√£o do teste:")
        print(f"   ü™ô Ativo: {self.selected_asset}")
        print(f"   üìà Estrat√©gia: {self.strategies[self.selected_strategy]['name']}")
        print(f"   ‚è∞ Timeframe: {self.timeframes[self.selected_timeframe]['name']}")
        
        if self.custom_start_date and self.custom_end_date:
            print(f"   üìÖ Per√≠odo: {self.custom_start_date} at√© {self.custom_end_date}")
        else:
            print(f"   üìÖ Per√≠odo: √öltimos 30 dias")
        
        print(f"\nüîÑ Simulando backtest...")
        
        # Simular resultados para demonstra√ß√£o
        import random
        
        total_trades = random.randint(15, 50)
        winning_trades = random.randint(int(total_trades * 0.4), int(total_trades * 0.8))
        losing_trades = total_trades - winning_trades
        
        initial_capital = self.capital_manager.current_capital if self.capital_manager else 10000
        final_capital = initial_capital * random.uniform(0.85, 1.25)
        pnl = final_capital - initial_capital
        roi = (pnl / initial_capital) * 100
        
        win_rate = (winning_trades / total_trades) * 100 if total_trades > 0 else 0
        
        print(f"\nüìä RESULTADOS DO BACKTEST:")
        print(f"   üí∞ Capital inicial: ${initial_capital:.2f}")
        print(f"   üíµ Capital final: ${final_capital:.2f}")
        print(f"   üìà P&L: ${pnl:+.2f}")
        print(f"   üìä ROI: {roi:+.2f}%")
        print(f"   üéØ Total de trades: {total_trades}")
        print(f"   ‚úÖ Trades vencedores: {winning_trades}")
        print(f"   ‚ùå Trades perdedores: {losing_trades}")
        print(f"   üìä Win Rate: {win_rate:.1f}%")
        
        # Atualizar capital se dispon√≠vel
        if self.capital_manager:
            self.capital_manager.update_capital(pnl)
            print(f"\nüí∞ Capital atualizado para: ${self.capital_manager.current_capital:.2f}")
        
        input("\nüìñ Pressione ENTER para continuar...")
    
    def _run_realtime_test(self):
        """Executa teste em tempo real"""
        if not self._validate_configuration():
            return
        
        print("\n‚ö° EXECUTANDO TESTE EM TEMPO REAL")
        print("="*50)
        
        print(f"üìä Configura√ß√£o do teste:")
        print(f"   ü™ô Ativo: {self.selected_asset}")
        print(f"   üìà Estrat√©gia: {self.strategies[self.selected_strategy]['name']}")
        print(f"   ‚è∞ Timeframe: {self.timeframes[self.selected_timeframe]['name']}")
        
        duration = input("\n‚è∞ Dura√ß√£o do teste em minutos (padr√£o: 5): ").strip()
        try:
            duration_minutes = int(duration) if duration else 5
        except ValueError:
            duration_minutes = 5
        
        print(f"\nüîÑ Simulando teste em tempo real por {duration_minutes} minutos...")
        print("‚ö†Ô∏è (Simula√ß√£o para demonstra√ß√£o)")
        
        # Simular monitoramento
        for i in range(min(duration_minutes, 10)):  # M√°ximo 10 itera√ß√µes para demonstra√ß√£o
            print(f"   üìä Minuto {i+1}: Monitorando {self.selected_asset}...")
            time.sleep(0.5)  # Simular delay
        
        # Simular resultados
        import random
        signals_generated = random.randint(0, 5)
        
        print(f"\nüìä RESULTADOS DO TESTE EM TEMPO REAL:")
        print(f"   ‚è∞ Dura√ß√£o: {duration_minutes} minutos")
        print(f"   üì° Sinais gerados: {signals_generated}")
        print(f"   üìä Status: Monitoramento conclu√≠do")
        
        if signals_generated > 0:
            print(f"   üéØ √öltimos sinais detectados com sucesso")
        else:
            print(f"   ‚ö†Ô∏è Nenhum sinal gerado no per√≠odo")
        
        input("\nüìñ Pressione ENTER para continuar...")
    
    def _view_test_results(self):
        """Visualiza resultados dos testes"""
        print("\nüìä VISUALIZAR RESULTADOS")
        print("="*50)
        
        if not self.test_history:
            print("‚ùå Nenhum teste executado ainda")
            print("üí° Execute um backtest ou teste em tempo real primeiro")
        else:
            print(f"üìà {len(self.test_history)} teste(s) no hist√≥rico:")
            for i, test in enumerate(self.test_history, 1):
                print(f"   {i}. {test['type']} - {test['asset']} - {test['strategy']}")
        
        input("\nüìñ Pressione ENTER para continuar...")
    
    def _export_results(self):
        """Exporta resultados para arquivo"""
        print("\nüì§ EXPORTAR RELAT√ìRIOS")
        print("="*50)
        
        if not self.test_history:
            print("‚ùå Nenhum resultado para exportar")
            print("üí° Execute um teste primeiro")
        else:
            # Criar diret√≥rio reports se n√£o existir
            reports_dir = Path("reports")
            reports_dir.mkdir(exist_ok=True)
            
            # Gerar nome do arquivo
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"strategy_lab_results_{timestamp}.json"
            filepath = reports_dir / filename
            
            # Salvar resultados
            export_data = {
                "export_timestamp": datetime.now().isoformat(),
                "strategy_lab_version": "V6",
                "test_history": self.test_history
            }
            
            try:
                with open(filepath, 'w', encoding='utf-8') as f:
                    json.dump(export_data, f, indent=2, ensure_ascii=False)
                
                print(f"‚úÖ Relat√≥rio exportado com sucesso!")
                print(f"üìÅ Arquivo: {filepath}")
                print(f"üìä {len(self.test_history)} teste(s) inclu√≠do(s)")
            except Exception as e:
                print(f"‚ùå Erro ao exportar: {e}")
        
        input("\nüìñ Pressione ENTER para continuar...")
